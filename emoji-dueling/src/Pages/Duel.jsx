/*
    This page will need a lot of changes for interactivity.

    User data should be taken from the server.
        Relevant user data: username, lives (max of 3), host state
        See full user object structure in the UserStatus component.
    Queston emoji should be generated by the server and taken from there.
    States to be handled by the server:
        isRevealed - hides / unhides emojis. Should reset each round and give a few seconds before revealing new emojis.
        playerTapStatus - used for handling correctness. -1 = awaiting server, 0 = no input, 1 = incorrect, 2 = correct
        opponentTapStatus - used for locking out responses after 1 tap. -1 = awaiting server, 0 = no input, 1 = input received
    Functions that should probably move to the server side:
        endRound(ender, isCorrect) - Determines who tapped faster, and if they were right.
        handleLifeChange(userLives, opponentLives) - Sets lives according to correct tap, resets round variables, and moves to gameover page.
        submitPlayerTap(emoji) - which emoji the player tapped. Should set the playerTapStatus.
        submitOpponentTap(emoji) - which emoji the opponent tapped. Should set opponentTapStatus.

    Calls to be sent to the server:
        submitPlayerTap(playerTapEmoji) - which emoji theplayer tapped
    Ensure navigate function works correctly with server.
       The generic links are as follows:
        /roomCode/isHost/Page
*/

/**
 * Note: instructions will be given in text like this, 
 * since I left a bunch of other comments here so that I could understand my own code after being away for a bit. 
 */

import { useEffect, useState } from "react"
import UserStatus from "../components/UserStatus"
import { useNavigate, useParams } from "react-router-dom"
import EmojiInput from "../components/EmojiInput"
import "../css/Duel.css"
/*
    TO DO: 
        ... setup a useContext to pass this data to the gameover page, probably. 

    Strech Goals:
        Randomize emoji list
        Send reaction times to the next page to determine the winner.
*/
function Duel(props) {
    const isTesting = true                                              // to test opponent responses


    const { roomCode, userIsHost: userIsHostParam } = useParams()       // Room code will eventually connect to the Server.
    const userIsHost = userIsHostParam === "host"                       // UserIsHost & OpponentIsHost are for styling the boxes
    const opponentIsHost = !userIsHost

    const [userUsername, setUserUsername] = useState(null)              // usernames and lives are for display in the boxes, and for tracking when the game ends.
    const [userLives, setUserLives] = useState(3)
    const [opponentUsername, setOpponentUsername] = useState(null)
    const [opponentLives, setOpponentLives] = useState(3)


    const [questionEmoji, setQuestionEmoji] = useState()                // questionEmoji and emojiList are so that we can dynamically display different emojis to be matched.
    const [emojiList, setEmojiList] = useState([])
    const [isRevealed, setIsRevealed] = useState(false)                 // isRevealed will allow users to see the emojis and tap them. (Won't accept tap unless revealed)

    [playerTapEmoji, setPlayerTapEmoji] = useState()                    // playerTapEmoji, playerTapStatus, and opponentTapStatus are all for validating taps & locking out once either responds.
    const [playerTapStatus, setPlayerTapStatus] = useState(0)
    const [opponentTapStatus, setOpponentTapStatus] = useState(0)

    const [gameover, setGameover] = useState(false)                     // gameover ensures that no further taps are made once the game ends


    const [roundText, setRoundText] = useState("")                      // roundText is for feedback so you know what's happening, roundStart is for measuring reaction time,
    const [roundStart, setRoundStart] = useState(Date.now());
    const [reactionTimes, setReactionTimes] = useState([])              // and reactionTimes are used to determine when the tap came in and also score at the end of the match

    const navigate = useNavigate()                                      // This is so that we can use useNavigate

    /**
     * The server should set up all of this data.
     */
    useEffect(() => {                                                   // Establish mock variables for the user, opponent, and the emojis we're using.
        if (isTesting) {                                                // once the server is set up, this should use actual sever values.
            setUserUsername("ðŸ˜ˆ Moji Master")
            setOpponentUsername("ðŸ‘‘ Moticon Champion")
            setEmojiList(["ðŸ˜ˆ", "ðŸ‘‘", "ðŸ‘»", "ðŸ“‹"])
            setQuestionEmoji("ðŸ˜ˆ")
        }
    }, ([]))

    /**
     * The server should probably handle life changes.
     */
    function handleLifeChange(userLives, opponentLives) {               // This handles game over, the end of a round, and moves you to the gameover page
        if (userLives <= 0 || opponentLives <= 0) {
            setGameover(true)
            if (userLives > opponentLives) {
                setRoundText(`Game Over!\n You won!`)
            }
            else {
                setRoundText(`Game Over!\n You lost!`)
            }
            console.log(reactionTimes)
            // FIGURE OUT A BETTER WAY TO PASS THE REACTION TIMES FORWARD

            const moveToGameoverPage = setTimeout(() => {

                navigate(`/${roomCode}/${userIsHostParam}/gameover`, { state: { reactionTimes } })
            }, 3000);

            return () => clearTimeout(moveToGameoverPage)
        }
        else {
            const resetRoundVariables = setTimeout(() => {
                setIsRevealed(false)
                setPlayerTapStatus(0)
                setOpponentTapStatus(0)
                setRoundText("Go!")
                setRoundStart(Date.now());
                setIsRevealed(true)
                // Pick new emoji                               // UNFINISHED
            }, 3000);
            return () => clearTimeout(resetRoundVariables);
            // send also who was the ender

        }
    }

    useEffect(() => {
        handleLifeChange(userLives, opponentLives)
    }, ([userLives, opponentLives]))

    /**
     * The server should probably handle the endRound function.
     */
    function endRound(ender, isCorrect) {
        const roundEnd = Date.now();
        const timeElapsed = roundEnd - roundStart
        setReactionTimes(prev => [...prev, [ender, timeElapsed, isCorrect]]);
        return (timeElapsed)
    }

    /**
     * The server should probably handle submit player tap. 
     */
    function submitPlayerTap(emoji) {
        if (isTesting) {
            // LOCAL FAKE SERVER
            if (!(playerTapStatus > 0) && !(opponentTapStatus > 0) && !gameover && userLives > 0 && opponentLives > 0) {    // if the game is stll valid
                if (roundStart) {
                    const timeElapsed = endRound("player", emoji === questionEmoji)
                    if (emoji === questionEmoji) {                                                                          // if the user is right
                        setPlayerTapStatus(2);                                                                              // correct player tap
                        setOpponentLives(opponentLives - 1);
                        setRoundText("Nice one! " + timeElapsed)
                    } else {
                        setPlayerTapStatus(1);                                                                              // incorrect player tap
                        setUserLives(userLives - 1);
                        setRoundText("Not quite... " + timeElapsed)
                    }
                }
            }
        } else {
            // REAL SERVER CALL GOES HERE
            // Example:
            // socket.emit('playerTap', { emoji });
        }

    }

    /**
     * The server should probably handle this function
     * */
    function submitOpponentTapStatus(emoji) {
        if (isTesting) {
            if (!(playerTapStatus > 0) && !(opponentTapStatus > 0) && !gameover && userLives > 0 && opponentLives > 0) {    // if nobody's tapped yet, and the game isn't over

                setOpponentTapStatus(1)                                                                                     // opponent tap received
                if (roundStart) {
                    const timeElapsed = endRound("opponent", emoji === questionEmoji)
                    if (emoji === questionEmoji) {                                                                          // correct opponent tap
                        setUserLives(userLives - 1);
                        setRoundText("Too slow! " + timeElapsed)
                    } else {
                        setOpponentLives(opponentLives - 1);
                        setRoundText("Free Win! " + timeElapsed)
                    }
                }

            }
        }
    }

    /**
     * See if this needs updating. 
     */
    function handlePlayerTap(emoji) {
        setPlayerTapEmoji(emoji);
        setPlayerTapStatus(-1);                                                                                             // Waiting for server
        submitPlayerTap(emoji);
    }

    return (
        <>

            <UserStatus username={userUsername} lives={userLives} isHost={userIsHost} view="duel" />                        {/* player userStatus */}

            <div>

                <div className="emoji-input-container">                                                                     {/* question emoji and answer emojis */}
                    {roundText}
                    <EmojiInput emoji={questionEmoji} isQuestion={true} isRevealed={isRevealed}
                        questionEmoji={questionEmoji}
                        playerTapEmoji={playerTapEmoji}
                        opponentTapStatus={opponentTapStatus}
                        playerTapStatus={playerTapStatus}
                        onPlayerTap={handlePlayerTap} />
                    {emojiList.map((index, key) => {
                        return (<EmojiInput key={key}
                            emoji={index} isQuestion={false}
                            questionEmoji={questionEmoji} playerTapEmoji={playerTapEmoji}
                            opponentTapStatus={opponentTapStatus} playerTapStatus={playerTapStatus} isRevealed={isRevealed}
                            onPlayerTap={handlePlayerTap}                                                                   // Pass the function!
                        />)
                    })}
                </div>

                {/* This can be deleted once you've integrated the server. */}
                {isTesting ?                                                                                                /* for testing mock responses (just change the isTesting variable to enable all testing) */

                    <div>
                        <button onClick={() => {
                            if (isRevealed) {
                                submitOpponentTapStatus("ðŸ˜ˆ")
                            }
                        }} >Test Opponent ReactionðŸ˜ˆ</button>
                        <button onClick={() => {
                            if (isRevealed) {
                                submitOpponentTapStatus("ðŸ‘‘")
                            }
                        }} >Test Opponent ReactionðŸ‘‘</button>
                    </div>
                    : ""}
            </div>

            <UserStatus username={opponentUsername} lives={opponentLives} isHost={opponentIsHost} view="duel" />            {/* opponent userstatus */}
        </>
    )
}

export default Duel